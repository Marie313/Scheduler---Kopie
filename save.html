const allJobs = [
    {
        id: 1234,
        name: "Beispiel_1",
        enabled: true,
        status: "success",
        lastRun: "2024-01-12T11:24",
        nextRun: "2024-01-13T11:24",
        interval: "every_86.400_seconds",
        backgroundColor: "rgba(61, 255, 61, 0.75)"
    },
    {
        id: 2023,
        name: "Beispiel_2",
        enabled: true,
        status: "success",
        lastRun: "2023-06-14T22:24",
        nextRun: "2023-12-14T22:24",
        interval: "every_15.768.000_seconds",
        backgroundColor: "rgba(61, 255, 61, 0.75)"
    },
    {
        id: 5678,
        name: "Beispiel_3",
        enabled: true,
        status: "warning",
        lastRun: "2023-09-12T10:19",
        nextRun: "2023-11-12T10:15",
        interval: "every_7.884.000_seconds",
        backgroundColor: "rgba(255, 252, 71, 0.8)"
    },
    {
        id: 1010,
        name: "Beispiel_4",
        enabled: false,
        status: "none",
        lastRun: "-",
        nextRun: "-",
        interval: "-",
    },
    {
        id: 3103,
        name: "Beispiel_5",
        enabled: true,
        status: "failed",
        lastRun: "2023-10-08T09:35",
        nextRun: "2023-10-18T09:35",
        interval: "every_864.000_seconds",
        backgroundColor: "rgba(255, 66, 66, 0.73)"
    },
    {
        id: 9876,
        name: "Beispiel_6",
        enabled: true,
        status: "success",
        lastRun: "2023-10-12T10:01",
        nextRun: "2023-10-13T10:02",
        interval: "every_60_seconds",
        backgroundColor: "rgba(61,255, 61, 0.75)"
    },
    {
        id: 2005,
        name: "Beispiel_7",
        enabled: false,
        status: "success",
        lastRun: "2015-12-30T04:24",
        nextRun: "-",
        interval: "-",
        backgroundColor: "rgba(61, 255, 61, 0.75)"
    }
];

async function getJobs(){
    const response = await fetch('http://20.166.67.112:82/jobs',{
    method:'GET',
    headers:
        'Access-Control-Allow-Origin'
    
    });
    const jobs = await response.json();
    console.log(jobs);
}
getJobs();

var checkbox = document.querySelectorAll(".my-checkbox");
    var message = document.querySelectorAll(".message");
    checkbox.forEach(function(checkbox, index){
        checkbox.addEventListener('change', function(){
            if (checkbox.checked) {
                message[index].textContent = 'true';
            } else {
                message[index].textContent = 'false';
            }
        });
    });

    //Funktion zur Überprüfung des Status Feldes
    const statusInput = document.querySelector('.status');
    statusInput.addEventListener('change', function () {
        const selectedStatus = statusInput.value;
        if(selectedStatus != 'SUCCESS' && selectedStatus != 'FAILED' && selectedStatus != 'WARNING'){
            alert('Der eingegebene Status ist ungueltig. Bitte beachten Sie, dass nur folgende drei Eingaben akzeptiert werden: "SUCCESS","WARNING","FAILED".');
            statusInput.value = '';
        }
    })

    https://tomprojects.codes/scheduler/

const checkboxInputs = document.querySelectorAll('.my-checkbox');

checkboxInputs.forEach(function(checkboxInput) {
    checkboxInput.addEventListener('mousehover', function() {
        alert('Wenn Sie einen Job aktivieren oder deaktivieren wollen, muessen Sie ueber den Editor gehen.');
    });
});

{ type: 'label', text: 'ID: ' },
{ type: 'input', attributes: { type: 'text', placeholder: 'ID', class: 'ID'} },

const inputFirstRun = document.querySelector('.firstRun');
const inputNextRun = document.querySelector('.nextRun');

//Überprüfen des Wertes für nextRun
inputNextRun.addEventListener('change', function(){
    const currentDate = new Date();
    const selectedDateNext = new Date(inputNextRun.value);

    if (selectedDateNext < currentDate) {
        alert('Das fuer next Run ausgewaehlte Datum darf nicht in der Vergangenheit liegen.');
        inputNextRun.value='';
    }
})

//Überprüfen des Wertes für firstRun
inputFirstRun.addEventListener('change', function(){
    const maxDate = new Date();
    const selectedDateNext = new Date(inputNextRun.value);
    const selectedDateFirst = new Date(inputFirstRun.value)
    maxDate.setFullYear(currentDate.getFullYear() + 1);

    if (selectedDateFirst > selectedDateNext || selectedDateFirst >= maxDate){
        alert('Das fuer First Run ausgewaehlte Datum darf zeitlich gesehen, nicht nach dem next Run liegen. Des Weiteren sollte das ausgewaehlte Datum fuer first Run nicht mehr als ein Jahr in der Zukunft datiert sein.');
        inputFirstRun.value='';
    }
})

<div class="delete"><button class="deleteButton" data-jobId="123"><svg width="16" height="16"><use xlink:href="#delete-icon"></use></svg></button></div>

//Funktion zur Überprüfung des Status Feldes
    const statusInput = document.querySelector('.status');
    statusInput.addEventListener('change', function () {
        const selectedStatus = statusInput.value;
        if(selectedStatus != 'SUCCESS' && selectedStatus != 'FAILED' && selectedStatus != 'WARNING'){
            alert('Der eingegebene Status ist ungueltig. Bitte beachten Sie, dass nur folgende drei Eingaben akzeptiert werden: "SUCCESS","WARNING","FAILED".');
            statusInput.value = '';
        }
    })


    // Checkbox-Logik
const checkboxes = document.querySelectorAll(".my-checkbox");

checkboxes.forEach(function (checkbox) {
    checkbox.addEventListener('change', function () {
        const statusElement = checkbox.nextElementSibling; // Nächstes Element nach der Checkbox
        statusElement.textContent = checkbox.checked ? 'true' : 'false';
        });
    });

const firstRunInput = document.querySelector('.firstRun');
const nextRunInput = document.querySelector('.nextRun');
const lastRunInput = document.querySelector('.lastRun');
const intervalInput = document.querySelector('.interval');

//Überprüfung des firstRun
if(firstRunInput){
    firstRunInput.addEventListener('change', function () {
        updateInterval();
    });
}

//Überprüfung des nextRun
if(nextRunInput){
    nextRunInput.addEventListener('change', function(){
        updateInterval();
    });
}

//Überprüfeng des lastRun
if(lastRunInput){
    lastRunInput.addEventListener('change', function(){
        updateInterval();
    });
}

// Überprüfung des Interval-Felds
if (intervalInput) {
    intervalInput.addEventListener('change', function () {
        updateNextRun(); 
    });
}

// Funktion zum Aktualisieren des Next Runs basierend auf dem Interval
function updateNextRun() {
    const firstRunDate = new Date(document.querySelector('.firstRun').value);
    const intervalInSeconds = parseFloat(intervalInput.value);

    if (!isNaN(firstRunDate.getTime()) && !isNaN(intervalInSeconds)) {
        const nextRunDate = new Date(firstRunDate.getTime() + intervalInSeconds * 1000 + 3600000);

        const nextRunInput = document.querySelector('.nextRun');
        if (nextRunInput) {
            nextRunInput.value = nextRunDate.toISOString().slice(0, 16); // Formatierung für datetime-local
        }
}
}

function updateInterval(lastRun, activeFrom, nextRun) {
    const currentDate = new Date();
    const lastRunDate = new Date(lastRun);
    const nullDate = new Date("0001-12-31T23:06:32");
    const firstRunDate = new Date(activeFrom);
    const nextRunDate = new Date(nextRun);

    if (firstRunDate > currentDate || lastRunDate.getTime() === nullDate.getTime()){
        const intervalInSecondsFirst = Math.abs((nextRunDate - firstRunDate) / 1000);
        return `${intervalInSecondsFirst} seconds`;
    }
    else{
        if (!isNaN(lastRunDate.getTime()) && !isNaN(nextRunDate.getTime())) {
            const intervalInSeconds = Math.abs((nextRunDate - lastRunDate) / 1000);
            return `${intervalInSeconds} seconds`;
        } 
        else{ 
            return 'not avail'
        }
    }
}

function sortTable(n) {
    var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
    table = document.getElementById("myTable2");
    switching = true;
    // Set the sorting direction to ascending:
    dir = "asc";
    /* Make a loop that will continue until
    no switching has been done: */
    while (switching) {
      // Start by saying: no switching is done:
      switching = false;
      rows = table.rows;
      /* Loop through all table rows (except the
      first, which contains table headers): */
      for (i = 1; i < (rows.length - 1); i++) {
        // Start by saying there should be no switching:
        shouldSwitch = false;
        /* Get the two elements you want to compare,
        one from current row and one from the next: */
        x = rows[i].getElementsByTagName("TD")[n];
        y = rows[i + 1].getElementsByTagName("TD")[n];
        /* Check if the two rows should switch place,
        based on the direction, asc or desc: */
        if (dir == "asc") {
          if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
            // If so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        } else if (dir == "desc") {
          if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
            // If so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        }
      }
      if (shouldSwitch) {
        /* If a switch has been marked, make the switch
        and mark that a switch has been done: */
        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
        switching = true;
        // Each time a switch is done, increase this count by 1:
        switchcount ++;
      } else {
        /* If no switching has been done AND the direction is "asc",
        set the direction to "desc" and run the while loop again. */
        if (switchcount == 0 && dir == "asc") {
          dir = "desc";
          switching = true;
        }
      }
    }
  }